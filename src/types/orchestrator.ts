/**
 * Orchestrator Type Definitions
 *
 * Types for the orchestrator agent system that monitors and manages
 * terminal sessions running AI coding agents.
 */
import { z } from "zod";

// ============================================================================
// Enum Types
// ============================================================================

/**
 * Orchestrator Type
 * - master: Root-level orchestrator monitoring all sessions
 * - sub_orchestrator: Folder-scoped orchestrator for specific projects
 */
export type OrchestratorType = "master" | "sub_orchestrator";

export const OrchestratorTypeSchema = z.enum(["master", "sub_orchestrator"]);

/**
 * Orchestrator Status
 * - idle: Not currently analyzing (waiting for next poll)
 * - analyzing: Currently examining sessions
 * - acting: Performing interventions
 * - paused: Monitoring paused by user
 */
export type OrchestratorStatus = "idle" | "analyzing" | "acting" | "paused";

export const OrchestratorStatusSchema = z.enum([
  "idle",
  "analyzing",
  "acting",
  "paused",
]);

/**
 * Orchestrator Scope Type
 * - folder: Scoped to a specific folder
 * - null: No scope (master orchestrator)
 */
export type OrchestratorScopeType = "folder" | null;

export const OrchestratorScopeTypeSchema = z.enum(["folder"]).nullable();

/**
 * Insight Type
 * - stall_detected: Session appears stalled (no activity)
 * - performance: Performance-related observation
 * - error: Error or failure detected
 * - suggestion: Optimization or improvement suggestion
 */
export type InsightType =
  | "stall_detected"
  | "performance"
  | "error"
  | "suggestion";

export const InsightTypeSchema = z.enum([
  "stall_detected",
  "performance",
  "error",
  "suggestion",
]);

/**
 * Insight Severity
 * - info: Informational, no action needed
 * - warning: Attention recommended
 * - error: Problem requiring attention
 * - critical: Urgent problem requiring immediate action
 */
export type InsightSeverity = "info" | "warning" | "error" | "critical";

export const InsightSeveritySchema = z.enum([
  "info",
  "warning",
  "error",
  "critical",
]);

/**
 * Audit Log Action Type
 * - insight_generated: Orchestrator generated an insight
 * - command_injected: Orchestrator injected a command to a session
 * - session_monitored: Orchestrator checked a session
 * - status_changed: Orchestrator status changed
 */
export type AuditLogActionType =
  | "insight_generated"
  | "command_injected"
  | "session_monitored"
  | "status_changed";

export const AuditLogActionTypeSchema = z.enum([
  "insight_generated",
  "command_injected",
  "session_monitored",
  "status_changed",
]);

// ============================================================================
// Core Interfaces
// ============================================================================

/**
 * Orchestrator Session
 * Represents an orchestrator agent running in a terminal session
 */
export interface OrchestratorSession {
  id: string;
  sessionId: string; // Link to terminal_session
  userId: string;
  type: OrchestratorType;
  status: OrchestratorStatus;
  scopeType: OrchestratorScopeType;
  scopeId: string | null;
  customInstructions: string | null;
  monitoringInterval: number; // seconds
  stallThreshold: number; // seconds
  autoIntervention: boolean;
  lastActivityAt: Date;
  createdAt: Date;
  updatedAt: Date;
}

export const OrchestratorSessionSchema = z.object({
  id: z.string().uuid(),
  sessionId: z.string().uuid(),
  userId: z.string().uuid(),
  type: OrchestratorTypeSchema,
  status: OrchestratorStatusSchema,
  scopeType: OrchestratorScopeTypeSchema,
  scopeId: z.string().uuid().nullable(),
  customInstructions: z.string().nullable(),
  monitoringInterval: z.number().int().positive(),
  stallThreshold: z.number().int().positive(),
  autoIntervention: z.boolean(),
  lastActivityAt: z.date(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

/**
 * Orchestrator Insight
 * Represents an observation or recommendation generated by an orchestrator
 */
export interface OrchestratorInsight {
  id: string;
  orchestratorId: string;
  sessionId: string | null; // Target session (if session-specific)
  type: InsightType;
  severity: InsightSeverity;
  message: string;
  contextJson: string | null; // Additional structured context
  suggestedActions: string | null; // JSON array of suggested actions
  resolved: boolean;
  resolvedAt: Date | null;
  createdAt: Date;
}

export const OrchestratorInsightSchema = z.object({
  id: z.string().uuid(),
  orchestratorId: z.string().uuid(),
  sessionId: z.string().uuid().nullable(),
  type: InsightTypeSchema,
  severity: InsightSeveritySchema,
  message: z.string().min(1),
  contextJson: z.string().nullable(),
  suggestedActions: z.string().nullable(),
  resolved: z.boolean(),
  resolvedAt: z.date().nullable(),
  createdAt: z.date(),
});

/**
 * Orchestrator Audit Log Entry
 * Immutable record of orchestrator actions
 */
export interface OrchestratorAuditLogEntry {
  id: string;
  orchestratorId: string;
  actionType: AuditLogActionType;
  targetSessionId: string | null; // Target session (if action is session-specific)
  detailsJson: string | null; // Action details (JSON)
  createdAt: Date;
}

export const OrchestratorAuditLogEntrySchema = z.object({
  id: z.string().uuid(),
  orchestratorId: z.string().uuid(),
  actionType: AuditLogActionTypeSchema,
  targetSessionId: z.string().uuid().nullable(),
  detailsJson: z.string().nullable(),
  createdAt: z.date(),
});

// ============================================================================
// Configuration Interfaces
// ============================================================================

/**
 * Orchestrator Configuration
 * User-configurable settings for an orchestrator
 */
export interface OrchestratorConfig {
  customInstructions?: string;
  monitoringInterval?: number; // seconds
  stallThreshold?: number; // seconds
  autoIntervention?: boolean;
  insightTypes?: InsightType[]; // Which insight types to generate
}

export const OrchestratorConfigSchema = z.object({
  customInstructions: z.string().optional(),
  monitoringInterval: z.number().int().positive().optional(),
  stallThreshold: z.number().int().positive().optional(),
  autoIntervention: z.boolean().optional(),
  insightTypes: z.array(InsightTypeSchema).optional(),
});

/**
 * Create Orchestrator Request
 * Input for creating a new orchestrator
 */
export interface CreateOrchestratorRequest {
  type: OrchestratorType;
  scopeType?: OrchestratorScopeType;
  scopeId?: string;
  config?: OrchestratorConfig;
}

export const CreateOrchestratorRequestSchema = z.object({
  type: OrchestratorTypeSchema,
  scopeType: OrchestratorScopeTypeSchema.optional(),
  scopeId: z.string().uuid().optional(),
  config: OrchestratorConfigSchema.optional(),
});

/**
 * Update Orchestrator Request
 * Input for updating orchestrator configuration
 */
export interface UpdateOrchestratorRequest {
  config?: OrchestratorConfig;
  status?: OrchestratorStatus;
}

export const UpdateOrchestratorRequestSchema = z.object({
  config: OrchestratorConfigSchema.optional(),
  status: OrchestratorStatusSchema.optional(),
});

/**
 * Create Insight Request
 * Input for creating a new insight
 */
export interface CreateInsightRequest {
  sessionId?: string;
  type: InsightType;
  severity: InsightSeverity;
  message: string;
  context?: Record<string, unknown>;
  suggestedActions?: string[];
}

export const CreateInsightRequestSchema = z.object({
  sessionId: z.string().uuid().optional(),
  type: InsightTypeSchema,
  severity: InsightSeveritySchema,
  message: z.string().min(1),
  context: z.record(z.unknown()).optional(),
  suggestedActions: z.array(z.string()).optional(),
});

/**
 * Insight Context
 * Structured context data for insights
 */
export interface InsightContext {
  lastActivity?: Date;
  scrollbackSnapshot?: string;
  commandHistory?: string[];
  errorMessages?: string[];
  performanceMetrics?: Record<string, number>;
  [key: string]: unknown;
}

/**
 * Suggested Action
 * An action that can be taken to resolve an insight
 */
export interface SuggestedAction {
  label: string;
  description: string;
  command?: string; // Command to inject (if applicable)
  dangerous?: boolean; // Requires user confirmation
}

// ============================================================================
// Query Interfaces
// ============================================================================

/**
 * List Orchestrators Query
 * Filters for listing orchestrators
 */
export interface ListOrchestratorsQuery {
  type?: OrchestratorType;
  status?: OrchestratorStatus;
  scopeType?: OrchestratorScopeType;
  scopeId?: string;
}

export const ListOrchestratorsQuerySchema = z.object({
  type: OrchestratorTypeSchema.optional(),
  status: OrchestratorStatusSchema.optional(),
  scopeType: OrchestratorScopeTypeSchema.optional(),
  scopeId: z.string().uuid().optional(),
});

/**
 * List Insights Query
 * Filters for listing insights
 */
export interface ListInsightsQuery {
  orchestratorId?: string;
  sessionId?: string;
  type?: InsightType;
  severity?: InsightSeverity;
  resolved?: boolean;
}

export const ListInsightsQuerySchema = z.object({
  orchestratorId: z.string().uuid().optional(),
  sessionId: z.string().uuid().optional(),
  type: InsightTypeSchema.optional(),
  severity: InsightSeveritySchema.optional(),
  resolved: z.boolean().optional(),
});

/**
 * List Audit Log Query
 * Filters for listing audit log entries
 */
export interface ListAuditLogQuery {
  orchestratorId?: string;
  actionType?: AuditLogActionType;
  targetSessionId?: string;
  startDate?: Date;
  endDate?: Date;
}

export const ListAuditLogQuerySchema = z.object({
  orchestratorId: z.string().uuid().optional(),
  actionType: AuditLogActionTypeSchema.optional(),
  targetSessionId: z.string().uuid().optional(),
  startDate: z.date().optional(),
  endDate: z.date().optional(),
});

// ============================================================================
// Response Interfaces
// ============================================================================

/**
 * Orchestrator with Metadata
 * Extended orchestrator with related data
 */
export interface OrchestratorWithMetadata extends OrchestratorSession {
  session: {
    name: string;
    tmuxSessionName: string;
    status: string;
  };
  insightCounts: {
    total: number;
    unresolved: number;
    bySeverity: Record<InsightSeverity, number>;
  };
  lastAuditEntry?: OrchestratorAuditLogEntry;
}

/**
 * Insight with Context
 * Insight with parsed context and actions
 */
export interface InsightWithContext extends OrchestratorInsight {
  context?: InsightContext;
  actions?: SuggestedAction[];
}

// ============================================================================
// Stall Detection Types
// ============================================================================

/**
 * Scrollback Snapshot
 * Captured state of a session's scrollback buffer
 */
export interface ScrollbackSnapshot {
  sessionId: string;
  timestamp: Date;
  content: string;
  hash: string; // Hash for quick comparison
  lineCount: number;
}

/**
 * Stall Detection Result
 * Result of analyzing a session for staleness
 */
export interface StallDetectionResult {
  sessionId: string;
  isStalled: boolean;
  lastActivity: Date;
  unchangedDuration: number; // seconds
  confidence: number; // 0-1
  reason?: string;
}

// ============================================================================
// Command Injection Types
// ============================================================================

/**
 * Command Injection Request
 * Request to inject a command into a session
 */
export interface CommandInjectionRequest {
  sessionId: string;
  command: string;
  pressEnter?: boolean;
  reason?: string; // Why the command is being injected
}

export const CommandInjectionRequestSchema = z.object({
  sessionId: z.string().uuid(),
  command: z.string().min(1),
  pressEnter: z.boolean().optional().default(true),
  reason: z.string().optional(),
});

/**
 * Command Injection Result
 * Result of injecting a command
 */
export interface CommandInjectionResult {
  success: boolean;
  sessionId: string;
  command: string;
  timestamp: Date;
  auditLogId: string;
  error?: string;
}
