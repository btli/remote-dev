/**
 * OrchestratorInsight - Domain entity representing an insight generated by an orchestrator.
 *
 * An insight is an observation or recommendation about a session's state,
 * such as detecting a stalled session or identifying a performance issue.
 *
 * Invariants:
 * - An insight must have a valid orchestrator ID
 * - An insight must have a valid type
 * - An insight must have a valid severity
 * - An insight must have a non-empty message
 * - Resolved insights must have a resolvedAt timestamp
 * - Unresolved insights must not have a resolvedAt timestamp
 */

import { InvalidValueError, InvariantViolationError } from "../errors/DomainError";
import type { InsightType, InsightSeverity, InsightContext, SuggestedAction } from "@/types/orchestrator";

export interface OrchestratorInsightProps {
  id: string;
  orchestratorId: string;
  sessionId: string | null; // Target session (if session-specific)
  type: InsightType;
  severity: InsightSeverity;
  message: string;
  context: InsightContext | null;
  suggestedActions: SuggestedAction[];
  resolved: boolean;
  resolvedAt: Date | null;
  createdAt: Date;
}

export interface CreateInsightProps {
  id?: string;
  orchestratorId: string;
  sessionId?: string | null;
  type: InsightType;
  severity: InsightSeverity;
  message: string;
  context?: InsightContext | null;
  suggestedActions?: SuggestedAction[];
}

export class OrchestratorInsight {
  private constructor(private readonly props: OrchestratorInsightProps) {
    this.validateInvariants();
  }

  private validateInvariants(): void {
    // Validate required fields
    if (!this.props.id || typeof this.props.id !== "string") {
      throw new InvalidValueError("OrchestratorInsight.id", this.props.id, "Must be a non-empty string");
    }
    if (!this.props.orchestratorId || typeof this.props.orchestratorId !== "string") {
      throw new InvalidValueError(
        "OrchestratorInsight.orchestratorId",
        this.props.orchestratorId,
        "Must be a non-empty string"
      );
    }

    // Validate type
    const validTypes = ["stall_detected", "performance", "error", "suggestion"];
    if (!validTypes.includes(this.props.type)) {
      throw new InvalidValueError(
        "OrchestratorInsight.type",
        this.props.type,
        `Must be one of: ${validTypes.join(", ")}`
      );
    }

    // Validate severity
    const validSeverities = ["info", "warning", "error", "critical"];
    if (!validSeverities.includes(this.props.severity)) {
      throw new InvalidValueError(
        "OrchestratorInsight.severity",
        this.props.severity,
        `Must be one of: ${validSeverities.join(", ")}`
      );
    }

    // Validate message
    if (!this.props.message || this.props.message.trim().length === 0) {
      throw new InvalidValueError("OrchestratorInsight.message", this.props.message, "Must be a non-empty string");
    }

    // Validate resolved state
    if (this.props.resolved && !this.props.resolvedAt) {
      throw new InvariantViolationError(
        "Resolved insights must have a resolvedAt timestamp",
        "RESOLVED_WITHOUT_TIMESTAMP"
      );
    }
    if (!this.props.resolved && this.props.resolvedAt) {
      throw new InvariantViolationError(
        "Unresolved insights must not have a resolvedAt timestamp",
        "UNRESOLVED_WITH_TIMESTAMP"
      );
    }
  }

  /**
   * Create a new OrchestratorInsight with unresolved status.
   */
  static create(props: CreateInsightProps): OrchestratorInsight {
    const id = props.id ?? crypto.randomUUID();
    const now = new Date();

    return new OrchestratorInsight({
      id,
      orchestratorId: props.orchestratorId,
      sessionId: props.sessionId ?? null,
      type: props.type,
      severity: props.severity,
      message: props.message.trim(),
      context: props.context ?? null,
      suggestedActions: props.suggestedActions ?? [],
      resolved: false,
      resolvedAt: null,
      createdAt: now,
    });
  }

  /**
   * Reconstitute an OrchestratorInsight from persistence.
   * Used by repositories when loading from database.
   */
  static reconstitute(props: OrchestratorInsightProps): OrchestratorInsight {
    return new OrchestratorInsight(props);
  }

  // ============================================================================
  // Getters
  // ============================================================================

  get id(): string {
    return this.props.id;
  }

  get orchestratorId(): string {
    return this.props.orchestratorId;
  }

  get sessionId(): string | null {
    return this.props.sessionId;
  }

  get type(): InsightType {
    return this.props.type;
  }

  get severity(): InsightSeverity {
    return this.props.severity;
  }

  get message(): string {
    return this.props.message;
  }

  get context(): InsightContext | null {
    return this.props.context;
  }

  get suggestedActions(): SuggestedAction[] {
    // Deep clone to prevent nested object mutation
    return this.props.suggestedActions.map((action) => ({
      label: action.label,
      description: action.description,
      command: action.command,
      dangerous: action.dangerous,
    }));
  }

  get resolved(): boolean {
    return this.props.resolved;
  }

  get resolvedAt(): Date | null {
    return this.props.resolvedAt ? new Date(this.props.resolvedAt.getTime()) : null;
  }

  get createdAt(): Date {
    return new Date(this.props.createdAt.getTime());
  }

  // ============================================================================
  // Business Logic Methods
  // ============================================================================

  /**
   * Check if this insight is session-specific.
   */
  isSessionSpecific(): boolean {
    return this.props.sessionId !== null;
  }

  /**
   * Check if this insight is critical (requires immediate attention).
   */
  isCritical(): boolean {
    return this.props.severity === "critical";
  }

  /**
   * Check if this insight is an error.
   */
  isError(): boolean {
    return this.props.severity === "error" || this.props.severity === "critical";
  }

  /**
   * Check if this insight is informational.
   */
  isInformational(): boolean {
    return this.props.severity === "info";
  }

  /**
   * Check if this insight has suggested actions.
   */
  hasSuggestedActions(): boolean {
    return this.props.suggestedActions.length > 0;
  }

  /**
   * Check if this insight has context data.
   */
  hasContext(): boolean {
    return this.props.context !== null;
  }

  /**
   * Resolve the insight.
   * Returns a new OrchestratorInsight instance with resolved status.
   */
  resolve(): OrchestratorInsight {
    if (this.props.resolved) {
      return this; // Already resolved
    }

    return new OrchestratorInsight({
      ...this.props,
      resolved: true,
      resolvedAt: new Date(),
    });
  }

  /**
   * Unresolve the insight (if incorrectly resolved).
   * Returns a new OrchestratorInsight instance with unresolved status.
   */
  unresolve(): OrchestratorInsight {
    if (!this.props.resolved) {
      return this; // Already unresolved
    }

    return new OrchestratorInsight({
      ...this.props,
      resolved: false,
      resolvedAt: null,
    });
  }

  /**
   * Add a suggested action to the insight.
   * Returns a new OrchestratorInsight instance with added action.
   */
  addSuggestedAction(action: SuggestedAction): OrchestratorInsight {
    return new OrchestratorInsight({
      ...this.props,
      suggestedActions: [...this.props.suggestedActions, action],
    });
  }

  /**
   * Update the insight message.
   * Returns a new OrchestratorInsight instance with updated message.
   */
  updateMessage(message: string): OrchestratorInsight {
    const trimmedMessage = message.trim();
    if (!trimmedMessage) {
      throw new InvalidValueError("message", message, "Must be a non-empty string");
    }

    return new OrchestratorInsight({
      ...this.props,
      message: trimmedMessage,
    });
  }

  /**
   * Update the context data.
   * Returns a new OrchestratorInsight instance with updated context.
   */
  updateContext(context: InsightContext | null): OrchestratorInsight {
    return new OrchestratorInsight({
      ...this.props,
      context,
    });
  }

  /**
   * Get age of insight in milliseconds.
   */
  getAge(): number {
    return Date.now() - this.props.createdAt.getTime();
  }

  /**
   * Get age of insight in seconds.
   */
  getAgeInSeconds(): number {
    return Math.floor(this.getAge() / 1000);
  }

  /**
   * Check if insight is older than a given duration (in seconds).
   */
  isOlderThan(seconds: number): boolean {
    return this.getAgeInSeconds() > seconds;
  }

  /**
   * Get a summary string for logging/display.
   */
  getSummary(): string {
    const sessionInfo = this.props.sessionId ? ` (session: ${this.props.sessionId})` : "";
    const actionCount = this.props.suggestedActions.length;
    const actions = actionCount > 0 ? ` with ${actionCount} suggested action(s)` : "";
    return `[${this.props.severity.toUpperCase()}] ${this.props.type}${sessionInfo}: ${this.props.message}${actions}`;
  }

  /**
   * Get full props (for persistence).
   */
  toProps(): OrchestratorInsightProps {
    return { ...this.props };
  }
}
