//! Session management routes.

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    routing::{delete, get, patch, post},
    Extension, Json, Router,
};
use rdv_core::{
    db::types::{NewSession, Session},
    tmux,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

use crate::middleware::AuthContext;
use crate::state::AppState;

/// Create session router
pub fn router() -> Router<Arc<AppState>> {
    Router::new()
        .route("/sessions", get(list_sessions).post(create_session))
        .route(
            "/sessions/:id",
            get(get_session).patch(update_session).delete(close_session),
        )
        .route("/sessions/:id/suspend", post(suspend_session))
        .route("/sessions/:id/resume", post(resume_session))
        .route("/sessions/:id/exec", post(exec_command))
        .route("/sessions/:id/scrollback", get(get_scrollback))
}

#[derive(Debug, Deserialize)]
pub struct ListSessionsQuery {
    pub folder_id: Option<String>,
    pub status: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct SessionResponse {
    pub id: String,
    pub name: String,
    pub tmux_session_name: String,
    pub status: String,
    pub project_path: Option<String>,
    pub folder_id: Option<String>,
    pub worktree_branch: Option<String>,
    pub agent_provider: Option<String>,
    pub is_orchestrator_session: bool,
    pub created_at: i64,
    pub updated_at: i64,
}

impl From<Session> for SessionResponse {
    fn from(s: Session) -> Self {
        Self {
            id: s.id,
            name: s.name,
            tmux_session_name: s.tmux_session_name,
            status: s.status,
            project_path: s.project_path,
            folder_id: s.folder_id,
            worktree_branch: s.worktree_branch,
            agent_provider: s.agent_provider,
            is_orchestrator_session: s.is_orchestrator_session,
            created_at: s.created_at,
            updated_at: s.updated_at,
        }
    }
}

/// List sessions
pub async fn list_sessions(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Query(query): Query<ListSessionsQuery>,
) -> Result<Json<Vec<SessionResponse>>, (StatusCode, String)> {
    let user_id = auth.user_id();

    let sessions = state
        .db
        .list_sessions(user_id, query.folder_id.as_deref())
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Filter by status if provided
    let sessions: Vec<SessionResponse> = sessions
        .into_iter()
        .filter(|s| {
            query
                .status
                .as_ref()
                .map_or(true, |status| &s.status == status)
        })
        .map(SessionResponse::from)
        .collect();

    Ok(Json(sessions))
}

#[derive(Debug, Deserialize)]
pub struct CreateSessionRequest {
    pub name: String,
    pub project_path: Option<String>,
    pub folder_id: Option<String>,
    pub worktree_branch: Option<String>,
    pub agent_provider: Option<String>,
    pub is_orchestrator_session: Option<bool>,
    pub shell_command: Option<String>,
    pub environment: Option<std::collections::HashMap<String, String>>,
}

/// Create a new session
pub async fn create_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Json(req): Json<CreateSessionRequest>,
) -> Result<(StatusCode, Json<SessionResponse>), (StatusCode, String)> {
    let user_id = auth.user_id();

    // Generate tmux session name (we'll use the DB-generated ID)
    let temp_tmux_name = format!("rdv-{}", &uuid::Uuid::new_v4().to_string()[..8]);

    // Create tmux session
    let config = tmux::CreateSessionConfig {
        session_name: temp_tmux_name.clone(),
        working_directory: req.project_path.clone(),
        command: req.shell_command.clone(),
        auto_respawn: false,
        env: req.environment.clone(),
    };

    tmux::create_session(&config).map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to create tmux session: {}", e),
        )
    })?;

    // Create database record (ID is generated by create_session)
    let new_session = NewSession {
        user_id: user_id.to_string(),
        name: req.name.clone(),
        tmux_session_name: temp_tmux_name,
        project_path: req.project_path,
        folder_id: req.folder_id,
        worktree_branch: req.worktree_branch,
        agent_provider: req.agent_provider,
        is_orchestrator_session: req.is_orchestrator_session.unwrap_or(false),
    };

    let session_id = state
        .db
        .create_session(&new_session)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Fetch the created session
    let session = state
        .db
        .get_session(&session_id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok((StatusCode::CREATED, Json(SessionResponse::from(session))))
}

/// Get a session by ID
pub async fn get_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    // Verify ownership
    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    Ok(Json(SessionResponse::from(session)))
}

#[derive(Debug, Deserialize)]
pub struct UpdateSessionRequest {
    pub name: Option<String>,
    pub folder_id: Option<String>,
}

/// Update a session
pub async fn update_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
    Json(req): Json<UpdateSessionRequest>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Update session
    if let Some(name) = req.name {
        state
            .db
            .update_session_name(&id, &name)
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    }

    if let Some(folder_id) = req.folder_id {
        state
            .db
            .update_session_folder(&id, Some(&folder_id))
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    }

    // Fetch updated session
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok(Json(SessionResponse::from(session)))
}

/// Close a session
pub async fn close_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<StatusCode, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Kill tmux session
    let _ = tmux::kill_session(&session.tmux_session_name);

    // Update database
    state
        .db
        .update_session_status(&id, "closed")
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(StatusCode::NO_CONTENT)
}

/// Suspend a session
pub async fn suspend_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Update status to suspended
    state
        .db
        .update_session_status(&id, "suspended")
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Fetch updated session
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok(Json(SessionResponse::from(session)))
}

/// Resume a session
pub async fn resume_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Check if tmux session still exists
    let tmux_exists = tmux::session_exists(&session.tmux_session_name).unwrap_or(false);

    if !tmux_exists {
        return Err((
            StatusCode::CONFLICT,
            "tmux session no longer exists".to_string(),
        ));
    }

    // Update status to active
    state
        .db
        .update_session_status(&id, "active")
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Fetch updated session
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok(Json(SessionResponse::from(session)))
}

#[derive(Debug, Deserialize)]
pub struct ExecCommandRequest {
    pub command: String,
}

/// Execute a command in a session
pub async fn exec_command(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
    Json(req): Json<ExecCommandRequest>,
) -> Result<StatusCode, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Send keys to tmux session
    tmux::send_keys(&session.tmux_session_name, &req.command, true)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(StatusCode::ACCEPTED)
}

#[derive(Debug, Deserialize)]
pub struct ScrollbackQuery {
    pub lines: Option<u32>,
}

#[derive(Debug, Serialize)]
pub struct ScrollbackResponse {
    pub content: String,
}

/// Get scrollback from a session
pub async fn get_scrollback(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
    Query(query): Query<ScrollbackQuery>,
) -> Result<Json<ScrollbackResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Capture tmux scrollback
    let lines = query.lines.unwrap_or(100);
    let content = tmux::capture_pane(&session.tmux_session_name, Some(lines))
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(Json(ScrollbackResponse { content }))
}
