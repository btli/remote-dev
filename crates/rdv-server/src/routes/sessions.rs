//! Session management routes.

use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    routing::{get, post},
    Extension, Json, Router,
};
use rdv_core::{
    db::types::{NewSession, Session},
    tmux,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tracing::{info, warn};

use crate::middleware::AuthContext;
use crate::state::AppState;

/// Create session router
pub fn router() -> Router<Arc<AppState>> {
    Router::new()
        .route("/sessions", get(list_sessions).post(create_session))
        .route("/sessions/reorder", post(reorder_sessions))
        .route(
            "/sessions/:id",
            get(get_session).patch(update_session).delete(close_session),
        )
        .route("/sessions/:id/suspend", post(suspend_session))
        .route("/sessions/:id/resume", post(resume_session))
        .route("/sessions/:id/exec", post(exec_command))
        .route("/sessions/:id/scrollback", get(get_scrollback))
}

#[derive(Debug, Deserialize)]
pub struct ListSessionsQuery {
    pub folder_id: Option<String>,
    pub status: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct SessionResponse {
    pub id: String,
    pub name: String,
    pub tmux_session_name: String,
    pub status: String,
    pub project_path: Option<String>,
    pub folder_id: Option<String>,
    pub worktree_branch: Option<String>,
    pub agent_provider: Option<String>,
    pub is_orchestrator_session: bool,
    pub created_at: i64,
    pub updated_at: i64,
}

impl From<Session> for SessionResponse {
    fn from(s: Session) -> Self {
        Self {
            id: s.id,
            name: s.name,
            tmux_session_name: s.tmux_session_name,
            status: s.status,
            project_path: s.project_path,
            folder_id: s.folder_id,
            worktree_branch: s.worktree_branch,
            agent_provider: s.agent_provider,
            is_orchestrator_session: s.is_orchestrator_session,
            created_at: s.created_at,
            updated_at: s.updated_at,
        }
    }
}

/// List sessions
pub async fn list_sessions(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Query(query): Query<ListSessionsQuery>,
) -> Result<Json<Vec<SessionResponse>>, (StatusCode, String)> {
    let user_id = auth.user_id();

    let sessions = state
        .db
        .list_sessions(user_id, query.folder_id.as_deref())
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Filter by status if provided
    let sessions: Vec<SessionResponse> = sessions
        .into_iter()
        .filter(|s| {
            query
                .status
                .as_ref()
                .map_or(true, |status| &s.status == status)
        })
        .map(SessionResponse::from)
        .collect();

    Ok(Json(sessions))
}

#[derive(Debug, Deserialize)]
pub struct CreateSessionRequest {
    pub name: String,
    pub project_path: Option<String>,
    pub folder_id: Option<String>,
    pub worktree_branch: Option<String>,
    pub agent_provider: Option<String>,
    pub is_orchestrator_session: Option<bool>,
    pub shell_command: Option<String>,
    pub environment: Option<std::collections::HashMap<String, String>>,
}

/// Create a new session
pub async fn create_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Json(req): Json<CreateSessionRequest>,
) -> Result<(StatusCode, Json<SessionResponse>), (StatusCode, String)> {
    let user_id = auth.user_id();
    let is_orchestrator = req.is_orchestrator_session.unwrap_or(false);

    // Generate tmux session name (we'll use the DB-generated ID)
    let temp_tmux_name = format!("rdv-{}", &uuid::Uuid::new_v4().to_string()[..8]);

    // Create tmux session
    let config = tmux::CreateSessionConfig {
        session_name: temp_tmux_name.clone(),
        working_directory: req.project_path.clone(),
        command: req.shell_command.clone(),
        auto_respawn: false,
        env: req.environment.clone(),
    };

    tmux::create_session(&config).map_err(|e| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Failed to create tmux session: {}", e),
        )
    })?;

    // Create database record (ID is generated by create_session)
    let new_session = NewSession {
        user_id: user_id.to_string(),
        name: req.name.clone(),
        tmux_session_name: temp_tmux_name,
        project_path: req.project_path.clone(),
        folder_id: req.folder_id.clone(),
        worktree_branch: req.worktree_branch,
        agent_provider: req.agent_provider,
        is_orchestrator_session: is_orchestrator,
    };

    let session_id = state
        .db
        .create_session(&new_session)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Auto-init Master Control for non-orchestrator sessions
    // This ensures orchestration is available when the first session is created
    if !is_orchestrator {
        if let Err(e) = ensure_master_control(&state, user_id).await {
            // Log error but don't fail session creation
            warn!("Failed to ensure Master Control for user {}: {}", user_id, e);
        }
    }

    // Fetch the created session
    let session = state
        .db
        .get_session(&session_id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok((StatusCode::CREATED, Json(SessionResponse::from(session))))
}

/// Ensure Master Control orchestrator exists for a user.
///
/// If no Master Control exists, creates a "pending_bootstrap" orchestrator record.
/// The actual bootstrap (CLAUDE.md, start Claude) happens via TypeScript on server startup.
async fn ensure_master_control(state: &AppState, user_id: &str) -> Result<(), String> {
    // Check if Master Control already exists
    match state.db.get_master_orchestrator(user_id) {
        Ok(Some(_)) => {
            // Master Control exists, nothing to do
            Ok(())
        }
        Ok(None) => {
            // No Master Control - create a pending orchestrator record
            info!("Creating pending Master Control for user {}", user_id);

            let orchestrator_id = uuid::Uuid::new_v4().to_string();

            // Create orchestrator with session_id = None and status = "pending_bootstrap"
            // TypeScript's initializeOrchestrators() will detect this and complete bootstrap
            state.db.create_orchestrator_simple(
                &orchestrator_id,
                user_id,
                None,  // folder_id (None for master)
                None,  // session_id (None - will be linked after bootstrap)
                "master",
                30,    // monitoring_interval
                300,   // stall_threshold
            ).map_err(|e| e.to_string())?;

            // Update status to pending_bootstrap
            state.db.update_orchestrator_status(&orchestrator_id, "pending_bootstrap")
                .map_err(|e| e.to_string())?;

            info!("Created pending Master Control orchestrator: {}", &orchestrator_id[..8]);
            Ok(())
        }
        Err(e) => Err(format!("Failed to check Master Control: {}", e)),
    }
}

/// Get a session by ID
pub async fn get_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    // Verify ownership
    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    Ok(Json(SessionResponse::from(session)))
}

#[derive(Debug, Deserialize)]
pub struct UpdateSessionRequest {
    pub name: Option<String>,
    pub folder_id: Option<String>,
}

/// Update a session
pub async fn update_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
    Json(req): Json<UpdateSessionRequest>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Update session
    if let Some(name) = req.name {
        state
            .db
            .update_session_name(&id, &name)
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    }

    if let Some(folder_id) = req.folder_id {
        state
            .db
            .update_session_folder(&id, Some(&folder_id))
            .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    }

    // Fetch updated session
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok(Json(SessionResponse::from(session)))
}

/// Close a session
pub async fn close_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<StatusCode, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Kill tmux session
    let _ = tmux::kill_session(&session.tmux_session_name);

    // Update database
    state
        .db
        .update_session_status(&id, "closed")
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(StatusCode::NO_CONTENT)
}

/// Suspend a session
pub async fn suspend_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Update status to suspended
    state
        .db
        .update_session_status(&id, "suspended")
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Fetch updated session
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok(Json(SessionResponse::from(session)))
}

/// Resume a session
pub async fn resume_session(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
) -> Result<Json<SessionResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Check if tmux session still exists
    let tmux_exists = tmux::session_exists(&session.tmux_session_name).unwrap_or(false);

    if !tmux_exists {
        return Err((
            StatusCode::CONFLICT,
            "tmux session no longer exists".to_string(),
        ));
    }

    // Update status to active
    state
        .db
        .update_session_status(&id, "active")
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Fetch updated session
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    Ok(Json(SessionResponse::from(session)))
}

#[derive(Debug, Deserialize)]
pub struct ExecCommandRequest {
    pub command: String,
}

/// Execute a command in a session
pub async fn exec_command(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
    Json(req): Json<ExecCommandRequest>,
) -> Result<StatusCode, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Send keys to tmux session
    tmux::send_keys(&session.tmux_session_name, &req.command, true)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(StatusCode::ACCEPTED)
}

#[derive(Debug, Deserialize)]
pub struct ScrollbackQuery {
    pub lines: Option<u32>,
}

#[derive(Debug, Serialize)]
pub struct ScrollbackResponse {
    pub content: String,
}

/// Get scrollback from a session
pub async fn get_scrollback(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Path(id): Path<String>,
    Query(query): Query<ScrollbackQuery>,
) -> Result<Json<ScrollbackResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    // Get session and verify ownership
    let session = state
        .db
        .get_session(&id)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .ok_or((StatusCode::NOT_FOUND, "Session not found".to_string()))?;

    if session.user_id != user_id {
        return Err((StatusCode::FORBIDDEN, "Access denied".to_string()));
    }

    // Capture tmux scrollback
    let lines = query.lines.unwrap_or(100);
    let content = tmux::capture_pane(&session.tmux_session_name, Some(lines))
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    Ok(Json(ScrollbackResponse { content }))
}

#[derive(Debug, Deserialize)]
pub struct ReorderSessionsRequest {
    pub session_ids: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct ReorderSessionsResponse {
    pub success: bool,
}

/// Reorder sessions (update tab order)
pub async fn reorder_sessions(
    State(state): State<Arc<AppState>>,
    Extension(auth): Extension<AuthContext>,
    Json(req): Json<ReorderSessionsRequest>,
) -> Result<Json<ReorderSessionsResponse>, (StatusCode, String)> {
    let user_id = auth.user_id();

    state
        .db
        .reorder_sessions(user_id, &req.session_ids)
        .map_err(|e| (StatusCode::BAD_REQUEST, e.to_string()))?;

    Ok(Json(ReorderSessionsResponse { success: true }))
}
