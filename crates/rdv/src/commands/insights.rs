//! Insights command implementation.
//!
//! View and manage orchestrator insights (stall detection, errors, suggestions).
//! Insights are generated by the monitoring service when issues are detected.

use anyhow::Result;
use chrono::{TimeZone, Utc};
use colored::Colorize;

use crate::cli::{InsightsAction, InsightsCommand};
use crate::config::Config;
use crate::db::Database;
use crate::error::RdvError;

pub async fn execute(cmd: InsightsCommand, _config: &Config) -> Result<()> {
    match cmd.action {
        InsightsAction::List {
            orchestrator,
            unresolved,
            all,
        } => list_insights(orchestrator, unresolved, all).await,
        InsightsAction::Show { insight_id } => show_insight(&insight_id).await,
        InsightsAction::Resolve { insight_id, notes } => {
            resolve_insight(&insight_id, notes.as_deref()).await
        }
        InsightsAction::Stalled { threshold } => check_stalled(threshold).await,
    }
}

async fn list_insights(
    orchestrator_id: Option<String>,
    unresolved: bool,
    all: bool,
) -> Result<()> {
    let db = Database::open()?;

    // Get orchestrator ID - use provided, or default to Master Control
    let orch_id = if let Some(id) = orchestrator_id {
        id
    } else {
        // Get Master Control orchestrator ID
        let user = db
            .get_default_user()?
            .ok_or_else(|| anyhow::anyhow!("No user found in database"))?;
        let orch = db
            .get_master_orchestrator(&user.id)?
            .ok_or_else(|| anyhow::anyhow!("No Master Control orchestrator found"))?;
        orch.id
    };

    // Determine filter
    let resolved_filter = if all {
        None // Show all
    } else if unresolved {
        Some(false) // Only unresolved
    } else {
        Some(false) // Default to unresolved
    };

    let insights = db.list_insights(&orch_id, resolved_filter)?;

    println!("{}", "Orchestrator Insights".cyan().bold());
    println!("{}", "─".repeat(60));

    if insights.is_empty() {
        let filter_desc = match resolved_filter {
            Some(false) => "unresolved ",
            Some(true) => "resolved ",
            None => "",
        };
        println!("  No {}insights found", filter_desc);
        return Ok(());
    }

    println!("  Found {} insight(s)", insights.len());
    println!();

    for insight in &insights {
        let status = if insight.resolved {
            "RESOLVED".green()
        } else {
            match insight.severity.as_str() {
                "high" => "HIGH".red(),
                "medium" => "MEDIUM".yellow(),
                _ => "LOW".white(),
            }
        };

        let created = Utc.timestamp_millis_opt(insight.created_at).single();
        let time_str = created
            .map(|t| t.format("%Y-%m-%d %H:%M").to_string())
            .unwrap_or_else(|| "Unknown".to_string());

        println!(
            "  {} [{}] {}",
            insight.id[..8].cyan(),
            status,
            insight.title
        );
        println!(
            "      Type: {} | Confidence: {:.0}% | Created: {}",
            insight.insight_type,
            insight.confidence * 100.0,
            time_str
        );
        if let Some(ref session_id) = insight.session_id {
            println!("      Session: {}", &session_id[..8]);
        }
        println!();
    }

    Ok(())
}

async fn show_insight(insight_id: &str) -> Result<()> {
    let db = Database::open()?;

    // Get user to find orchestrator
    let user = db
        .get_default_user()?
        .ok_or_else(|| anyhow::anyhow!("No user found in database"))?;

    // Get Master Control to list insights
    let orch = db
        .get_master_orchestrator(&user.id)?
        .ok_or_else(|| anyhow::anyhow!("No Master Control orchestrator found"))?;

    // List all insights and find the one matching the ID prefix
    let insights = db.list_insights(&orch.id, None)?;
    let insight = insights
        .iter()
        .find(|i| i.id.starts_with(insight_id))
        .ok_or_else(|| anyhow::anyhow!("Insight not found: {}", insight_id))?;

    println!("{}", "Insight Details".cyan().bold());
    println!("{}", "─".repeat(60));

    let status = if insight.resolved {
        "RESOLVED".green()
    } else {
        match insight.severity.as_str() {
            "high" => "HIGH".red(),
            "medium" => "MEDIUM".yellow(),
            _ => "LOW".white(),
        }
    };

    println!("  ID:          {}", insight.id);
    println!("  Status:      {}", status);
    println!("  Type:        {}", insight.insight_type);
    println!("  Severity:    {}", insight.severity);
    println!("  Confidence:  {:.0}%", insight.confidence * 100.0);
    println!("  Triggered:   {}", insight.triggered_by);

    let created = Utc.timestamp_millis_opt(insight.created_at).single();
    let created_str = created
        .map(|t| t.format("%Y-%m-%d %H:%M:%S").to_string())
        .unwrap_or_else(|| "Unknown".to_string());
    println!("  Created:     {}", created_str);

    println!();
    println!("  {}", "Title:".cyan());
    println!("    {}", insight.title);

    println!();
    println!("  {}", "Description:".cyan());
    for line in insight.description.lines() {
        println!("    {}", line);
    }

    if let Some(ref session_id) = insight.session_id {
        println!();
        println!("  {}", "Session:".cyan());
        println!("    {}", session_id);
    }

    if let Some(ref context) = insight.context {
        println!();
        println!("  {}", "Context:".cyan());
        // Try to pretty-print JSON context
        if let Ok(json) = serde_json::from_str::<serde_json::Value>(context) {
            println!("    {}", serde_json::to_string_pretty(&json)?);
        } else {
            println!("    {}", context);
        }
    }

    if let Some(ref actions) = insight.suggested_actions {
        println!();
        println!("  {}", "Suggested Actions:".cyan());
        // Try to parse as JSON array
        if let Ok(arr) = serde_json::from_str::<Vec<String>>(actions) {
            for (i, action) in arr.iter().enumerate() {
                println!("    {}. {}", i + 1, action);
            }
        } else {
            println!("    {}", actions);
        }
    }

    if insight.resolved {
        println!();
        println!("  {}", "Resolution:".green());
        if let Some(ref resolved_at) = insight.resolved_at {
            let resolved = Utc.timestamp_millis_opt(*resolved_at).single();
            let resolved_str = resolved
                .map(|t| t.format("%Y-%m-%d %H:%M:%S").to_string())
                .unwrap_or_else(|| "Unknown".to_string());
            println!("    Resolved at: {}", resolved_str);
        }
        if let Some(ref resolved_by) = insight.resolved_by {
            println!("    Resolved by: {}", resolved_by);
        }
        if let Some(ref notes) = insight.resolution_notes {
            println!("    Notes: {}", notes);
        }
    }

    Ok(())
}

async fn resolve_insight(insight_id: &str, notes: Option<&str>) -> Result<()> {
    let db = Database::open()?;

    // Get user for resolved_by field
    let user = db
        .get_default_user()?
        .ok_or_else(|| anyhow::anyhow!("No user found in database"))?;

    // Get Master Control to verify insight exists
    let orch = db
        .get_master_orchestrator(&user.id)?
        .ok_or_else(|| anyhow::anyhow!("No Master Control orchestrator found"))?;

    // Find the full insight ID
    let insights = db.list_insights(&orch.id, Some(false))?;
    let insight = insights
        .iter()
        .find(|i| i.id.starts_with(insight_id))
        .ok_or_else(|| anyhow::anyhow!("Unresolved insight not found: {}", insight_id))?;

    let resolved_by = user.email.as_deref().unwrap_or("cli");
    db.resolve_insight(&insight.id, resolved_by, notes)?;

    println!("{}", "Insight Resolved".green().bold());
    println!("  ID: {}", insight.id);
    println!("  Title: {}", insight.title);
    if let Some(n) = notes {
        println!("  Notes: {}", n);
    }

    Ok(())
}

async fn check_stalled(threshold: i64) -> Result<()> {
    let db = Database::open()?;

    // Get default user
    let user = db
        .get_default_user()?
        .ok_or_else(|| anyhow::anyhow!("No user found in database"))?;

    let stalled = db.get_stalled_sessions(&user.id, threshold)?;

    println!("{}", "Stalled Session Check".cyan().bold());
    println!("{}", "─".repeat(60));
    println!("  Threshold: {}s ({}m)", threshold, threshold / 60);
    println!();

    if stalled.is_empty() {
        println!("  {} No stalled sessions detected", "✓".green());
        return Ok(());
    }

    println!(
        "  {} Found {} potentially stalled session(s)",
        "⚠".yellow(),
        stalled.len()
    );
    println!();

    for session in &stalled {
        let stall_desc = if session.stalled_minutes < 0 {
            "never active".to_string()
        } else {
            format!("{}m inactive", session.stalled_minutes)
        };

        println!(
            "  {} {} ({})",
            "→".cyan(),
            session.session_name,
            stall_desc.yellow()
        );
        println!("      ID: {}", &session.session_id[..8]);
        println!("      tmux: {}", session.tmux_session_name);
        if let Some(ref folder_id) = session.folder_id {
            println!("      Folder: {}", &folder_id[..8]);
        }
        println!();
    }

    // Check for critical stall conditions that require escalation
    let critical_stalls: Vec<_> = stalled
        .iter()
        .filter(|s| s.stalled_minutes > 60) // More than 1 hour
        .collect();

    if critical_stalls.len() >= 3 {
        // Multiple critical stalls - escalation required
        return Err(RdvError::EscalationRequired(
            format!("{} sessions have been stalled for over an hour. Human intervention required.",
                    critical_stalls.len())
        ).into());
    }

    println!(
        "  Use '{}' to investigate",
        "rdv peek <session>".cyan()
    );
    println!(
        "  Use '{}' to send a nudge",
        "rdv nudge <session> <message>".cyan()
    );

    Ok(())
}
