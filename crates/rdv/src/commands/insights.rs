//! Insights command implementation.
//!
//! View and manage orchestrator insights (stall detection, errors, suggestions).
//! Insights are generated by the monitoring service when issues are detected.
//!
//! Uses rdv-server API for insight operations.

use anyhow::Result;
use colored::Colorize;

use rdv_core::client::ApiClient;

use crate::cli::{InsightsAction, InsightsCommand};
use crate::config::Config;
use crate::tmux;

pub async fn execute(cmd: InsightsCommand, _config: &Config) -> Result<()> {
    match cmd.action {
        InsightsAction::List {
            orchestrator,
            unresolved,
            all,
        } => list_insights(orchestrator, unresolved, all).await,
        InsightsAction::Show { insight_id } => show_insight(&insight_id).await,
        InsightsAction::Resolve { insight_id, notes } => {
            resolve_insight(&insight_id, notes.as_deref()).await
        }
        InsightsAction::Stalled { threshold } => check_stalled(threshold).await,
    }
}

async fn list_insights(
    orchestrator_id: Option<String>,
    unresolved: bool,
    all: bool,
) -> Result<()> {
    let client = ApiClient::new()?;

    // Get orchestrator ID - use provided, or default to Master Control
    let orch_id = if let Some(id) = orchestrator_id {
        id
    } else {
        // Get Master Control orchestrator ID
        let orch = client
            .get_master_orchestrator()
            .await?
            .ok_or_else(|| anyhow::anyhow!("No Master Control orchestrator found"))?;
        orch.id
    };

    // Determine filter description
    let filter_desc = if all {
        ""
    } else if unresolved {
        "unresolved "
    } else {
        "unresolved " // Default to unresolved
    };

    println!("{}", "Orchestrator Insights".cyan().bold());
    println!("{}", "─".repeat(60));

    // Note: Full insight API not yet implemented in rdv-server
    // For now, show placeholder message
    println!("  Orchestrator: {}", &orch_id[..8.min(orch_id.len())]);
    println!("  Filter: {}insights", filter_desc);
    println!();
    println!("  {} Insight listing via API not yet implemented", "⚠".yellow());
    println!("  Use the web UI to view insights");

    Ok(())
}

async fn show_insight(insight_id: &str) -> Result<()> {
    println!("{}", "Insight Details".cyan().bold());
    println!("{}", "─".repeat(60));

    // Note: Full insight API not yet implemented in rdv-server
    println!("  Insight ID: {}", insight_id);
    println!();
    println!("  {} Insight details via API not yet implemented", "⚠".yellow());
    println!("  Use the web UI to view insight details");

    Ok(())
}

async fn resolve_insight(insight_id: &str, notes: Option<&str>) -> Result<()> {
    println!("{}", "Resolving Insight...".cyan());

    // Note: Full insight API not yet implemented in rdv-server
    println!("  Insight ID: {}", insight_id);
    if let Some(n) = notes {
        println!("  Notes: {}", n);
    }
    println!();
    println!("  {} Insight resolution via API not yet implemented", "⚠".yellow());
    println!("  Use the web UI to resolve insights");

    Ok(())
}

async fn check_stalled(threshold: i64) -> Result<()> {
    println!("{}", "Stalled Session Check".cyan().bold());
    println!("{}", "─".repeat(60));
    println!("  Threshold: {}s ({}m)", threshold, threshold / 60);
    println!();

    // Check tmux sessions directly
    let sessions = tmux::list_sessions()?;
    let task_sessions: Vec<_> = sessions
        .iter()
        .filter(|s| s.name.starts_with("rdv-task-") || s.name.starts_with("rdv-session-"))
        .collect();

    if task_sessions.is_empty() {
        println!("  {} No task sessions to check", "✓".green());
        return Ok(());
    }

    println!("  Checking {} session(s)...", task_sessions.len());
    println!();

    // For stall detection, we'd need to compare scrollback hashes
    // This is simplified for now - just list sessions
    for session in &task_sessions {
        let status = if session.attached {
            "attached".green()
        } else {
            "detached".yellow()
        };
        println!("    {} ({})", session.name, status);
    }

    println!();
    println!(
        "  Use '{}' to investigate",
        "rdv peek <session>".cyan()
    );
    println!(
        "  Use '{}' to send a nudge",
        "rdv nudge <session> <message>".cyan()
    );

    Ok(())
}
